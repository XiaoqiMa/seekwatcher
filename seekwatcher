#!/usr/bin/env python
#
# Copyright (C) 2007 Oracle.  All rights reserved.
#
# To use seekwatcher, you need to download matplotlib, and have the numpy
# python lib installed on your box (this is the default w/many distro
# matplotlib packages).
#
# There are two basic modes for seekwatcher.  The first is to take
# an existing blktrace file and create a graph.  In this mode the two
# most important options are:
#
# -t (name of the trace file)
# -o (name of the output png)
#
#
# Example:
#
# blktrace -o read_trace -d /dev/sda &
#
# run your test
# kill blktrace
#
# seekwatcher -t read_trace -o trace.png
#
# Seekwatcher can also start blktrace for you, run a command, kill blktrace
# off and generate the plot.  -t and -o are still used, but you also send
# in the program to run and the device to trace.  The trace file is kept,
# so you can plot it again later with different args.
#
# Example:
#
# seekwatcher -t read_trace -o trace.png -p "dd if=/dev/sda of=/dev/zero" \
#       -d /dev/sda
#
# -z allows you to change the window used to zoom in on the most common
# data on the y axis.  Use min:max as numbers in MB where you want to 
# zoom. -z 0:0 forces no zooming at all.  The default tries to find the
# most common area of the disk hit and show only that.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License v2 as published by the Free Software Foundation.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public
# License along with this program; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 021110-1307, USA.
#
import sys, os, signal, time, commands
from optparse import OptionParser
from matplotlib import rcParams
from matplotlib.font_manager import fontManager, FontProperties
rcParams['numerix'] = 'numpy'
rcParams['backend'] = 'Agg'
rcParams['interactive'] = 'False'
import numpy
from pylab import *

def flag2num(flag):
    if flag == 'Q':
        return 0.0
    if flag == 'C':
        return 1.0
    if flag == 'U':
        return 2.0
    return 3.0
    sys.stderr.write("unknown flag %s\n" %flag)

def command2num(com):
    if com[0] == 'R':
        return 0.0
    if com[0] == 'W':
        return 1.0
    return 2.0
    sys.stderr.write("unknown command %s\n" % com)

def loaddata(fh,delimiter=None, converters=None):

    def iter(fh, delimiter, converters):
        if converters is None: converters = {}
        last_sector = None
        last_rw = None
        last_row = None
        last_end = None
        last_cmd = None
        last_size = None
        for i,line in enumerate(fh):
            row = [converters.get(i,float)(val) for i,val in enumerate(line.split(delimiter))]
            this_time = row[7]
            this_sector = row[4]
            this_rw = row[1]
            this_size = row[5] / 512
            this_cmd = row[0]
            if this_cmd != 1.0:
                continue

            if (last_row and this_rw == last_rw and
                this_time - last_time < .5 and this_cmd == last_cmd and
                last_size < 512 and
                this_sector == last_end):
                last_end += this_size
                last_size += this_size
                last_row[5] += row[5]
                continue
                
            if last_row:
                for x in last_row:
                    yield x
                
            last_row = row
            last_sector = this_sector
            last_time = this_time
            last_rw = this_rw
            last_end = this_sector + this_size
            last_cmd = this_cmd
            last_size = this_size
            for x in row:
                yield x

    X = numpy.fromiter(iter(fh, delimiter, converters), dtype=float)
    return X

def data_movie(data):
    def xycalc(sector):
        if sector < yzoommin or sector > yzoommax:
            return None
        sector = sector - yzoommin
        sector = sector / sectors_per_cell
        yval = floor(sector / num_cells)
        xval = sector % num_cells
        return (xval, yval)

    def add_frame(prev, ins, max):
        if len(prev) > max:
            del prev[0]
        prev.append(ins)
        
    
    num_cells = 600 / options.movie_cell_size
    total_cells = num_cells * num_cells
    sector_range = yzoommax - yzoommin
    sectors_per_cell = sector_range / total_cells
    total_secs = xmax - xmin
    movie_length = int(options.movie_length)
    movie_fps = int(options.movie_frames)
    total_frames = movie_length * movie_fps
    secs_per_frame = total_secs / total_frames
    print "total frames is %d secs per frame = %.2f\n" % (total_frames,
                                                          secs_per_frame)
    start_second = xmin

    times = data[:,7]
    figindex = 0

    fname, fname_ext = os.path.splitext(options.output)
    i = 0
    prev = []
    f = figure(figsize=(8,6))
    a = axes([ 0.10, 0.29, .85, .68 ])
    tput_ax = axes([ 0.10, 0.19, .85, .09 ])
    seek_ax = axes([ 0.10, 0.07, .85, .09 ])

    plot_seek_count(seek_ax, None, data, '-', None)
    ticks = seek_ax.get_yticks()
    ticks = list(arange(0, ticks[-1] + ticks[-1]/3 -1, ticks[-1]/3))
    seek_ax.set_yticks(ticks)
    seek_ax.set_yticklabels( [ str(int(x)) for x in ticks ], fontsize='x-small')
    seek_ax.set_ylabel('Seeks / sec', fontsize='x-small')
    seek_ax.set_xlabel('Time (seconds)', fontsize='x-small')
    seek_ax.grid(True)

    plot_throughput(tput_ax, None, data, '-', None)

    # cut down the number of yticks to something more reasonable
    ticks = tput_ax.get_yticks()
    ticks = list(arange(0, ticks[-1] + ticks[-1]/3 -1, ticks[-1]/3))
    tput_ax.set_yticks(ticks)
    tput_ax.set_xticks([])
    tput_ax.grid(True)

    if ticks[-1] < 3:
        tput_ax.set_yticklabels( [ "%.1f" % x for x in ticks ],
                                fontsize='x-small')
    else:
        tput_ax.set_yticklabels( [ "%d" % x for x in ticks ],
                                fontsize='x-small')

    tput_ax.set_ylabel('MB/s', fontsize='x-small')

    a.set_xticklabels([])
    a.set_yticklabels([])
    a.set_xlim(0, num_cells)
    a.set_ylim(0, num_cells)
    a.hold(False)
    datai = 0
    datalen = len(data)

    while i < total_frames and datai < datalen:
        start = start_second + i * secs_per_frame
        i += 1
        end = start + secs_per_frame
        if datai >= datalen or data[datai][7] > xmax:
            break
        xvals = []
        yvals = []
        while datai < datalen and data[datai][7] < end:
            row = data[datai]
            time = row[7]
            if time < start:
                print "dropping time %.2f < start %.2f" % (time, start)
                continue
            datai += 1
            sector = row[4]
            size = int(max(row[5] / 512, 1))
            rbs = row[1]
            cell = 0
            while cell < size:
                xy = xycalc(sector)
                sector += sectors_per_cell
                cell += sectors_per_cell
                if xy:
                    xvals.append(xy[0])
                    yvals.append(xy[1])
        if not xvals:
            continue
        add_frame(prev, (xvals, yvals), 10)
        alpha = 1.0
        a.hold(False)
        for x in xrange(len(prev)):
            vals = prev[x]
            if x == len(prev) - 1:
                alpha = 0
            else:
                alpha -= .1
            color = "%.2f" % alpha
            a.plot(vals[0], vals[1], 's', color=color, mfc=color,
                   mec=color, alpha=alpha, markersize=options.movie_cell_size)
            a.hold(True)
        a.set_xticklabels([])
        a.set_yticklabels([])
        a.set_xlim(0, num_cells)
        a.set_ylim(0, num_cells)
        line = seek_ax.axvline(x=end, color='k')
        line2 = tput_ax.axvline(x=end, color='k')
        tput_ax.set_xlim(xmin, xmax)
        seek_ax.set_xlim(xmin, xmax)
        print "start %.2f secs end %.2f secs frame %d" % (start, end, figindex)
        f.savefig("%s-%.6d%s" % (fname, figindex, fname_ext), dpi=options.dpi)
        line.set_linestyle('None')
        line2.set_linestyle('None')
        figindex += 1
    a.hold(True)

    os.system("mencoder mf://%s*.png -mf type=png:fps=%d -of mpeg -ovc lavc -lavcopts vcodec=mpeg2video -oac copy -o %s.mpg" % (fname, movie_fps, fname))

def plot_data(ax, rw, data, style, label, alpha=1):
    if rw != None:
        rbs = data[:,1]
        data = data[numpy.where(rbs == rw)]
    times = data[:,7]
    sectors = data[:,4]
    if len(times) > 0:
        return ax.plot(times, sectors, style, label=label, alpha=alpha)
    return []

def add_roll(roll, max, num):
    if len(roll) == max:
        del roll[0]
    roll.append(num)
    total = 0.0
    for x in roll:
        total += x
    return total / len(roll)

def plot_throughput(ax, rw, data, style, label, alpha=1):
    def tput_iter(sizes,times):
        bytes = 0.0
        sec = None
        roll = []
        for x in xrange(len(sizes)):
            size = sizes[x]
            cur_time = floor(times[x])
            if sec == None:
                avg = add_roll(roll, options.rolling_avg, 0.0)
                yield (0.0, avg)
                sec = cur_time
                continue
            if sec != cur_time:
                avg = add_roll(roll, options.rolling_avg, bytes)
                yield (sec, avg / (1024 * 1024))
                bytes = 0
                sec = cur_time
            bytes += size

    if rw != None:
        rbs = data[:,1]
        data = data[numpy.where(rbs == rw)]

    times = numpy.array([])
    tput = numpy.array([])
    for x,y in tput_iter(data[:,5], data[:,7]):
        times = numpy.append(times, x)
        tput = numpy.append(tput, y)

    return ax.plot(times, tput, style, label=label, alpha=alpha)

def plot_seek_count(ax, rw, data, style, label, alpha=1):
    def iter(sectors, times):
        count = 0.0
        last = None
        last_size = None
        sec = None
        roll = []
        for x in xrange(len(sectors)):
            sector = sectors[x]
            io_size = data[x][5] / 512
            cur_time = floor(times[x])
            if sec == None:
                avg = add_roll(roll, options.rolling_avg, 0.0)
                yield (0.0, avg)
                sec = cur_time
                continue
            if sec != cur_time:
                avg = add_roll(roll, options.rolling_avg, count)
                yield (sec, avg)
                count = 0
                sec = cur_time
            if last != None:
                diff = abs((last + last_size) - sector)
                if diff > 128:
                    count += 1
            last = sector
            last_size = io_size

    if rw != None:
        rbs = data[:,1]
        data = data[numpy.where(rbs == rw)]

    times = numpy.array([])
    counts = numpy.array([])
    for x,y in iter(data[:,4], data[:,7]):
        times = numpy.append(times, x)
        counts = numpy.append(counts, y)

    return ax.plot(times, counts, style, label=label, alpha=alpha)

def run_blktrace(trace, device):
    return os.spawnlp(os.P_NOWAIT, "blktrace", "-d", device, "-o", trace)

def run_prog(program, trace, device):
    blktrace_pid = run_blktrace(trace, device)
    sys.stderr.write("running :%s:\n" % program)
    os.system(program)
    sys.stderr.write("done running %s\n" % program)
    os.kill(blktrace_pid, signal.SIGTERM)
    pid, err = os.wait()
    if err:
        sys.stderr.write("exit due to blktrace failure %d\n" % err)
        exit(1)
    sys.stderr.write("blktrace done\n")

def run_blkparse(trace, converters):
    p = os.popen('blkparse -q -i ' + trace +
                 ' -f "%a %d %M %m %S %N %s %5T.%9t\n" | grep -v "^Input file"')
    data = loaddata(p, converters=converters)
    return data

def shapeit(X):
    lines = len(X) / 8
    X.shape = (lines, 8)

def getlabel(i):
    if i < len(options.label):
        return options.label[i]
    return ""

def running_config():
	"""
	Return path of config file of the currently running kernel
	"""
	version = commands.getoutput('uname -r')
	for config in ('/proc/config.gz', \
                       '/boot/config-%s' % version,
                       '/lib/modules/%s/build/.config' % version):
		if os.path.isfile(config):
			return config
	return None


def check_for_kernel_feature(feature):
	config = running_config()

	if not config:
		sys.stderr.write("Can't find kernel config file")

	if config.endswith('.gz'):
		grep = 'zgrep'
	else:
		grep = 'grep'
	grep += ' ^CONFIG_%s= %s' % (feature, config)

	if not commands.getoutput(grep):
		sys.stderr.write("Kernel doesn't have a %s feature\n" % (feature))
		sys.exit(1)

def check_for_debugfs():
	tmp = commands.getoutput('mount | grep /sys/kernel/debug')
	tmp = len(tmp)
	if tmp == 0:
		sys.stderr.write("debugfs not mounted (/sys/kernel/debug)\n")
		sys.exit(1)

usage = "usage: %prog [options]"
parser = OptionParser(usage=usage)
parser.add_option("-d", "--device", help="Device for blktrace", default="")
parser.add_option("-z", "--zoom", help="Zoom range min:max (in MB)", default="")
parser.add_option("-x", "--xzoom", help="Time range min:max (seconds)",
                default="")
parser.add_option("-t", "--trace", help="blktrace file", default=[],
                  action="append")
parser.add_option("-o", "--output", help="output file", default="trace.png")
parser.add_option("-p", "--prog", help="exec program", default="")
parser.add_option("-l", "--label", help="label", default=[], action="append")
parser.add_option("", "--dpi", help="dpi", default=120)
parser.add_option("", "--io-graph-dots", help="Disk IO dot style", default='.')
parser.add_option("-I", "--no-io-graph", help="Don't create an IO graph",
                  default=False, action="store_true")
parser.add_option("-r", "--rolling-avg", help="Rolling average for seeks and throughput (in seconds)", default=None)
parser.add_option("-m", "--movie", help="Generate an IO movie",
                  default=False, action="store_true")
parser.add_option("", "--movie-frames", help="Number of frames per second",
                  default=10)
parser.add_option("", "--movie-length", help="Movie length in seconds",
                  default=30)
parser.add_option("", "--movie-cell-size",
                  help="Size in pixels of the IO cells", default=2)

(options,args) = parser.parse_args()

options.movie_cell_size = float(options.movie_cell_size)
if not options.trace:
    parser.print_help()
    sys.exit(1)

converters = {}
converters[0] = flag2num
converters[1] = command2num

if options.prog:
    check_for_kernel_feature("DEBUG_FS")
    check_for_kernel_feature("BLK_DEV_IO_TRACE")
    check_for_debugfs()

    if not options.trace or not options.device:
        sys.stderr.write("blktrace output file or device not specified\n")
        sys.exit(1)
    run_prog(options.prog, options.trace[0], options.device)

data = numpy.array([])
runs = []
for x in options.trace:
    run = run_blkparse(x, converters)
    runs.append(run)
    data = numpy.append(data, run)

shapeit(data)
for x in runs:
    shapeit(x)
    if len(x) == 0:
        sys.stderr.write("Empty blktrace run found, exiting\n")
        sys.exit(1)

# try to drop out the least common data points by creating
# a historgram of the sectors seen.
sectors = data[:,4]
sizes = data[:,5]
ymean = numpy.mean(sectors)
sectormax = numpy.max(sectors)

if not options.zoom or ':' not in options.zoom:
    def all_bytes(data):
        for row in data:
            start = row[4]
            size = row[5] / 512
            yield start
            for x in xrange(int(size)):
                yield start + x + 1

    X = numpy.fromiter(all_bytes(data), dtype=float)

    hist, bound = numpy.histogram(X, bins=10)
    m = numpy.max(hist)
    bound = list(bound)
    bound.append(numpy.max(X))

    mbhist = []
    for i in xrange(len(bound) - 1):
        firsti = bound[i]
        lasti = bound[i + 1]
    for x in xrange(len(hist)):
        if m == hist[x]:
            maxi = x
    # hist[maxi] is the most common bucket.  walk toward it from the
    # min and max values looking for the first buckets that have some
    # significant portion of the data
    #
    yzoommin = bound[maxi]
    for x in xrange(0, maxi):
        if hist[x] > hist[maxi] * .05:
            yzoommin = bound[x]
            break

    yzoommax = bound[maxi + 1]
    for x in xrange(len(hist) - 1, maxi, -1):
        if hist[x] > hist[maxi] * .05:
            yzoommax = bound[x + 1]
            break
    X = None
else:
    words = options.zoom.split(':')
    yzoommin = max(0, float(words[0]) * 2048)
    if float(words[1]) == 0:
        yzoommax = sectormax
    else:
        yzoommax = min(sectormax, float(words[1]) * 2048)

sizes = 0
flags = [ x[:,0] for x in runs ]
times = data[:,7]
xmin = numpy.min(times)
xmax = numpy.max(times)

if options.rolling_avg == None:
    options.rolling_avg = max(1, int((xmax - xmin) / 25))
else:
    options.rolling_avg = max(1, int(options.rolling_avg))

if options.xzoom:
    words = [ float(x) for x in options.xzoom.split(':') ]
    if words[0] != 0:
        xmin = words[0]
    if words[1] != 0:
        xmax = words[1]

completed_data = []
for i in xrange(len(runs)):
    completed = numpy.where(flags[i] == 1)
    completed_data.append(runs[i][completed])

sectors = 0
flags = 0
completed = 0
times = 0

if options.no_io_graph:
    total_graphs = 2
else:
    total_graphs = 3

if options.movie:
    data_movie(completed_data[0])
    sys.exit(1)

f = figure(figsize=(8,6))


# Throughput goes at the botoom
a = subplot(total_graphs, 1, total_graphs)
for i in xrange(len(completed_data)):
    label = getlabel(i)
    plot_throughput(a, None, completed_data[i], '-', label)

# cut down the number of yticks to something more reasonable
ticks = a.get_yticks()
ticks = list(arange(0, ticks[-1] + ticks[-1]/4 -1, ticks[-1]/4))
a.set_yticks(ticks)

if ticks[-1] < 4:
    a.set_yticklabels( [ "%.1f" % x for x in ticks ])
else:
    a.set_yticklabels( [ "%d" % x for x in ticks ])

a.set_title('Throughput')
a.set_ylabel('MB/s')

# the bottom graph gets xticks, set it here
a.set_xlabel('Time (seconds)')
if options.label:
    a.legend(loc=(1.01, 0.5), shadow=True, pad=0.5, numpoints=2,
                  handletextsep = 0.005,
                  labelsep = 0.01,
                  prop=FontProperties(size='x-small') )

# next is the seek count graph
a = subplot(total_graphs, 1, total_graphs - 1)
for i in xrange(len(completed_data)):
    label = getlabel(i)
    plot_seek_count(a, None, completed_data[i], '-', label)

# cut down the number of yticks to something more reasonable
ticks = a.get_yticks()
ticks = list(arange(0, ticks[-1] + ticks[-1]/4 -1, ticks[-1]/4))
a.set_yticks(ticks)
a.set_yticklabels( [ str(int(x)) for x in ticks ])

a.set_title('Seek Count')
a.set_ylabel('Seeks / sec')
if options.label:
    a.legend(loc=(1.01, 0.5), shadow=True, pad=0.5, numpoints=2,
                  handletextsep = 0.005,
                  labelsep = 0.01,
                  prop=FontProperties(size='x-small') )

# and the optional IO graph
if not options.no_io_graph:
    a = subplot(total_graphs, 1, total_graphs - 2)
    for i in xrange(len(completed_data)):
        label = getlabel(i)
        plot_data(a, 0, completed_data[i], options.io_graph_dots,
                  label + " Read")
        plot_data(a, 1, completed_data[i], options.io_graph_dots,
                  label + " Write")

    a.set_title('Disk IO')
    a.set_ylabel('Disk offset (MB)')
    flag = data[:,0]
    completed = numpy.where(flag == 1)
    completed_data = data[completed]
    sectors = completed_data[:,4]
    zoom = (sectors > yzoommin) & (sectors < yzoommax)
    zoom = completed_data[zoom]
    sectors = zoom[:,4]
    yzoommin = numpy.min(sectors)
    yzommmax = numpy.max(sectors)
    ticks = list(arange(yzoommin, yzoommax, (yzoommax - yzoommin) / 4))
    ticks.append(yzoommax)
    a.set_yticks(ticks)
    a.set_yticklabels( [ str(int(x/2048)) for x in ticks ] )
    a.set_ylim(yzoommin, yzoommax)
    a.legend(loc=(1.01, 0.5), shadow=True, pad=0.3, numpoints=1,
                  handletextsep = 0.005,
                  labelsep = 0.01,
                  prop=FontProperties(size='x-small') )

# squeeze the graphs over to the left a bit to make room for the
# legends
#
subplots_adjust(right = 0.8, hspace=0.3)

# finally, some global bits for each subplot
for x in xrange(1, total_graphs + 1):
    a = subplot(total_graphs, 1, x)

    # turn off the xtick labels on the graphs above the bottom
    if x < total_graphs:
        a.set_xticklabels([])

    # set the xlimits to something sane
    a.set_xlim(xmin, xmax)

    # create dashed lines for each ytick
    ticks = a.get_yticks()
    for y in ticks[1:]:
        a.hlines(y, xmin, xmax, ls='--', alpha=0.5)

print "saving graph to %s" % options.output
savefig(options.output, dpi=options.dpi, orientation='landscape')
show()

