#!/usr/bin/env python
#
# To use seekwatcher, you need to download matplotlib, and have the numpy
# python lib installed on your box (this is the default w/many distro
# matplotlib packages).
#
# There are two basic modes for seekwatcher.  The first is to take
# an existing blktrace file and create a graph.  In this mode the two
# most important options are:
#
# -t (name of the trace file)
# -o (name of the output png)
#
#
# Example:
#
# blktrace -o read_trace -d /dev/sda &
#
# run your test
# kill blktrace
#
# seekwatcher -t read_trace -o trace.png
#
# Seekwatcher can also start blktrace for you, run a command, kill blktrace
# off and generate the plot.  -t and -o are still used, but you also send
# in the program to run and the device to trace.  The trace file is kept,
# so you can plot it again later with different args.
#
# Example:
#
# seekwatcher -t read_trace -o trace.png -p "dd if=/dev/sda of=/dev/zero" \
#       -d /dev/sda
#
# -z allows you to change the window used to zoom in on the most common
# data on the y axis.  Use min:max as numbers in MB where you want to 
# zoom. -z 0:0 forces no zooming at all.  The default tries to find the
# most common area of the disk hit and show only that.
#
import sys, os, signal, time
from optparse import OptionParser
from matplotlib import rcParams
from matplotlib.font_manager import fontManager, FontProperties
rcParams['numerix'] = 'numpy'
rcParams['backend'] = 'Agg'
rcParams['interactive'] = 'False'
import numpy
from pylab import *

def flag2num(flag):
    if flag == 'Q':
        return 0.0
    if flag == 'C':
        return 1.0
    if flag == 'U':
        return 2.0
    return 3.0
    sys.stderr.write("unknown flag %s\n" %flag)

def command2num(com):
    if com[0] == 'R':
        return 0.0
    if com[0] == 'W':
        return 1.0
    return 2.0
    sys.stderr.write("unknown command %s\n" % com)

def loaddata(fh,delimiter=None, converters=None):

    def iter(fh, delimiter, converters):
        if converters is None: converters = {}
        for i,line in enumerate(fh):
            row = [converters.get(i,float)(val) for i,val in enumerate(line.split(delimiter))]
            for x in row:
                yield x

    X = numpy.fromiter(iter(fh, delimiter, converters), dtype=float)
    return X

def plot_data(ax, rw, data, style, label, alpha=1):
    if rw != None:
        rbs = data[:,1]
        data = data[numpy.where(rbs == rw)]
    times = data[:,7]
    sectors = data[:,4]
    if len(times) > 0:
        return ax.plot(times, sectors, style, label=label, alpha=alpha)
    return []

def add_roll(roll, max, num):
    if len(roll) == max:
        del roll[0]
    roll.append(num)
    total = 0.0
    for x in roll:
        total += x
    return total / len(roll)

def plot_throughput(ax, rw, data, style, label, alpha=1):
    def tput_iter(sizes,times):
        bytes = 0.0
        sec = None
        roll = []
        for x in xrange(len(sizes)):
            size = sizes[x]
            cur_time = floor(times[x])
            if sec == None:
                avg = add_roll(roll, options.rolling_avg, 0.0)
                yield (0.0, avg)
                sec = cur_time
                continue
            if sec != cur_time:
                avg = add_roll(roll, options.rolling_avg, bytes)
                yield (sec, avg / (1024 * 1024))
                bytes = 0
                sec = cur_time
            bytes += size

    if rw != None:
        rbs = data[:,1]
        data = data[numpy.where(rbs == rw)]

    times = numpy.array([])
    tput = numpy.array([])
    for x,y in tput_iter(data[:,5], data[:,7]):
        times = numpy.append(times, x)
        tput = numpy.append(tput, y)

    return ax.plot(times, tput, style, label=label, alpha=alpha)

def plot_seek_count(ax, rw, data, style, label, alpha=1):
    def iter(sectors, times):
        count = 0.0
        last = None
        sec = None
        roll = []
        for x in xrange(len(sectors)):
            sector = sectors[x]
            cur_time = floor(times[x])
            if sec == None:
                avg = add_roll(roll, options.rolling_avg, 0.0)
                yield (0.0, avg)
                sec = cur_time
                continue
            if sec != cur_time:
                avg = add_roll(roll, options.rolling_avg, count)
                yield (sec, avg)
                count = 0
                sec = cur_time
            if last != None:
                diff = abs(last - sector)
                if diff > 128:
                    count += 1
            last = sector

    if rw != None:
        rbs = data[:,1]
        data = data[numpy.where(rbs == rw)]

    times = numpy.array([])
    counts = numpy.array([])
    for x,y in iter(data[:,4], data[:,7]):
        times = numpy.append(times, x)
        counts = numpy.append(counts, y)

    return ax.plot(times, counts, style, label=label, alpha=alpha)

def run_blktrace(trace, device):
    return os.spawnlp(os.P_NOWAIT, "blktrace", "-d", device, "-o", trace)

def run_prog(program, trace, device):
    blktrace_pid = run_blktrace(trace, device)
    sys.stderr.write("running :%s:\n" % program)
    os.system(program)
    sys.stderr.write("done running %s\n" % program)
    os.kill(blktrace_pid, signal.SIGTERM)
    pid, err = os.wait()
    if err:
        sys.stderr.write("exit due to blktrace failure %d\n" % err)
        exit(1)
    sys.stderr.write("blktrace done\n")

def run_blkparse(trace, converters):
    p = os.popen('blkparse -q -i ' + trace +
                 ' -f "%a %d %M %m %S %N %s %5T.%9t\n" | grep -v "^Input file"')
    data = loaddata(p, converters=converters)
    return data

def shapeit(X):
    lines = len(X) / 8
    X.shape = (lines, 8)

def getlabel(i):
    if i < len(options.label):
        return options.label[i]
    return ""

usage = "usage: %prog [options]"
parser = OptionParser(usage=usage)
parser.add_option("-d", "--device", help="Device for blktrace", default="")
parser.add_option("-z", "--zoom", help="Zoom range min:max (in MB)", default="")
parser.add_option("-x", "--xzoom", help="Time range min:max (seconds)",
                default="")
parser.add_option("-t", "--trace", help="blktrace file", default=[],
                  action="append")
parser.add_option("-o", "--output", help="output file", default="trace.png")
parser.add_option("-p", "--prog", help="exec program", default="")
parser.add_option("-l", "--label", help="label", default=[], action="append")
parser.add_option("", "--dpi", help="dpi", default=120)
parser.add_option("", "--io-graph-dots", help="Disk IO dot style", default='.')
parser.add_option("-I", "--no-io-graph", help="Don't create an IO graph",
                  default=False, action="store_true")
parser.add_option("-r", "--rolling-avg", help="Rolling average for seeks and throughput (seconds, def=5)", default=5)

(options,args) = parser.parse_args()
options.rolling_avg = int(options.rolling_avg)

if not options.trace:
    parser.print_help()
    sys.exit(1)

converters = {}
converters[0] = flag2num
converters[1] = command2num

if options.prog:
    if not options.trace or not options.device:
        sys.stderr.write("blktrace output file or device not specified\n")
        sys.exit(1)
    run_prog(options.prog, options.trace[0], options.device)

data = numpy.array([])
runs = []
for x in options.trace:
    run = run_blkparse(x, converters)
    runs.append(run)
    data = numpy.append(data, run)

shapeit(data)
for x in runs:
    shapeit(x)

# try to drop out the least common data points by creating
# a historgram of the sectors seen.
sectors = data[:,4]
ymean = numpy.mean(sectors)
sectormax = max(sectors)

if not options.zoom or ':' not in options.zoom:
    hist, bound = numpy.histogram(sectors, bins=10)
    m = numpy.max(hist)
    bound = list(bound)
    bound.append(sectormax)

    for x in xrange(len(hist)):
        if m == hist[x]:
            maxi = x
    # hist[maxi] is the most common bucket.  walk toward it from the
    # min and max values looking for the first buckets that have some
    # significant portion of the data
    #
    yzoommin = bound[maxi]
    for x in xrange(0, maxi):
        if hist[x] > hist[maxi] * .15:
            yzoommin = bound[x]
            break

    yzoommax = bound[maxi + 1]
    for x in xrange(len(hist) - 1, maxi, -1):
        if hist[x] > hist[maxi] * .15:
            yzoommax = bound[x + 1]
            break

else:
    words = options.zoom.split(':')
    yzoommin = max(0, float(words[0]) * 2048)
    if float(words[1]) == 0:
        yzoommax = sectormax
    else:
        yzoommax = min(sectormax, float(words[1]) * 2048)

flags = [ x[:,0] for x in runs ]
times = data[:,7]
xmin = min(times)
xmax = max(times)

if options.xzoom:
    words = [ float(x) for x in options.xzoom.split(':') ]
    if words[0] != 0:
        xmin = words[0]
    if words[1] != 0:
        xmax = words[1]

completed_data = []
for i in xrange(len(runs)):
    completed = numpy.where(flags[i] == 1)
    completed_data.append(runs[i][completed])

sectors = 0
flags = 0
completed = 0
times = 0

if options.no_io_graph:
    total_graphs = 2
else:
    total_graphs = 3

f = figure(figsize=(8,6))

# Throughput goes at the botoom
a = subplot(total_graphs, 1, total_graphs)
for i in xrange(len(completed_data)):
    label = getlabel(i)
    plot_throughput(a, None, completed_data[i], '-', label)

# cut down the number of yticks to something more reasonable
ticks = a.get_yticks()
ticks = list(arange(0, ticks[-1] + ticks[-1]/4 -1, ticks[-1]/4))
a.set_yticks(ticks)
a.set_yticklabels( [ str(int(x)) for x in ticks ])
a.set_title('Throughput')
a.set_ylabel('MB/s')

# the bottom graph gets xticks, set it here
a.set_xlabel('Time (seconds)')
if options.label:
    a.legend(loc=(1.01, 0.5), shadow=True, pad=0.5, numpoints=2,
                  handletextsep = 0.005,
                  labelsep = 0.01,
                  prop=FontProperties(size='x-small') )

# next is the seek count graph
a = subplot(total_graphs, 1, total_graphs - 1)
for i in xrange(len(completed_data)):
    label = getlabel(i)
    plot_seek_count(a, None, completed_data[i], '-', label)

# cut down the number of yticks to something more reasonable
ticks = a.get_yticks()
ticks = list(arange(0, ticks[-1] + ticks[-1]/4 -1, ticks[-1]/4))
a.set_yticks(ticks)
a.set_yticklabels( [ str(int(x)) for x in ticks ])

a.set_title('Seek Count')
a.set_ylabel('Seeks / sec')
if options.label:
    a.legend(loc=(1.01, 0.5), shadow=True, pad=0.5, numpoints=2,
                  handletextsep = 0.005,
                  labelsep = 0.01,
                  prop=FontProperties(size='x-small') )

# and the optional IO graph
if not options.no_io_graph:
    a = subplot(total_graphs, 1, total_graphs - 2)
    for i in xrange(len(completed_data)):
        label = getlabel(i)
        plot_data(a, 0, completed_data[i], options.io_graph_dots,
                  label + " Read")
        plot_data(a, 1, completed_data[i], options.io_graph_dots,
                  label + " Write")

    a.set_title('Disk IO')
    a.set_ylabel('Disk offset (MB)')
    flag = data[:,0]
    completed = numpy.where(flag == 1)
    completed_data = data[completed]
    sectors = completed_data[:,4]
    zoom = (sectors > yzoommin) & (sectors < yzoommax)
    zoom = completed_data[zoom]
    sectors = zoom[:,4]
    yzoommin = numpy.min(sectors)
    yzommmax = numpy.max(sectors)
    ticks = list(arange(yzoommin, yzoommax, (yzoommax - yzoommin) / 4))
    ticks.append(yzoommax)
    a.set_yticks(ticks)
    a.set_yticklabels( [ str(int(x/2048)) for x in ticks ] )
    a.set_ylim(yzoommin, yzoommax)
    a.legend(loc=(1.01, 0.5), shadow=True, pad=0.3, numpoints=1,
                  handletextsep = 0.005,
                  labelsep = 0.01,
                  prop=FontProperties(size='x-small') )

# squeeze the graphs over to the left a bit to make room for the
# legends
#
subplots_adjust(right = 0.8, hspace=0.3)

# finally, some global bits for each subplot
for x in xrange(1, total_graphs + 1):
    a = subplot(total_graphs, 1, x)

    # turn off the xtick labels on the graphs above the bottom
    if x < total_graphs:
        a.set_xticklabels([])

    # set the xlimits to something sane
    a.set_xlim(xmin, xmax)

    # create dashed lines for each ytick
    ticks = a.get_yticks()
    for y in ticks[1:]:
        a.hlines(y, xmin, xmax, ls='--', alpha=0.5)

print "saving graph to %s" % options.output
savefig(options.output, dpi=options.dpi, orientation='landscape')
show()

